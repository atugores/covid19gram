#!/bin/env python
# -*- coding: utf-8 -*-
import string
import configparser
from apscheduler.schedulers.asyncio import AsyncIOScheduler
import os
import re
import asyncio
from datetime import timedelta
from pyrogram import Client, filters, idle
from pyrogram.types import InlineKeyboardButton, InlineKeyboardMarkup, InputMediaPhoto, ReplyKeyboardMarkup, InlineQueryResultArticle, InputTextMessageContent
from pyrogram.errors import BadRequest
from covid19plot import COVID19Plot
from config.getdata import update_data, status_data
from config.countries import countries
from config.settings import DBHandler
import gettext
import redis
from uuid import uuid4
import logging

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

config_file = "conf.ini"
config = configparser.ConfigParser()
config.read(config_file, encoding="utf-8")

admins = list(map(int, config["USER"]["admin"].split(',')))
app = Client(
    "covid19bot",
    bot_token=config["API"]["api_token"],
    api_id=config["API"]["API_ID"],
    api_hash=config["API"]["API_HASH"]
)
cplt = COVID19Plot()
all_regions = []
for scope in cplt.SCOPES:
    all_regions.extend(cplt.get_regions(scope))
all_regions.sort()
cplt.get_regions(scope)

translations = {}
dbhd = DBHandler()
cache = redis.Redis(host='localhost', port=6379, db=0)
CACHE_PREFIX = 'COVID'
MAXTEXT = 3000

for language in cplt.LANGUAGES:
    translation = gettext.translation('messages', localedir='locales', languages=[language])
    translation.install()
    translations[language] = translation


async def exception_handle(user, e):
    if "USER_IS_BLOCKED" in str(e):
        logging.info(str(user) + ": Blocked the bot")
        return True
    elif "INPUT_USER_DEACTIVATED" in str(e):
        logging.info(str(user) + ": deactivated account")
        return True
    return False


def separa_qlsvl(text):
    separat = []
    max = MAXTEXT
    number = (len(text) - 1) // max + 2
    j = 0
    for i in range(1, number):
        separat.append((text[j * max: i * max]).rstrip(" \n"))
        j = i
    return separat


def separa_espais(text):
    paraules = text.split(" ")
    separat = []
    info = ""
    llarg = 0
    for paraula in paraules:
        if len(paraula) >= MAXTEXT:
            aux = separa_qlsvl(info + paraula)
            separat = separat + aux[: -1]
            info = (aux[-1] + " ").lstrip(" \n")
            llarg = len(info)
        elif llarg + len(paraula) >= MAXTEXT:
            separat.append(info.rstrip(" \n"))
            llarg = len(paraula)
            info = (paraula + " ").lstrip(" \n")
        else:
            llarg = llarg + len(paraula)
            info = (info + paraula + " ").lstrip(" \n")
    separat.append(info.rstrip(" "))
    return separat


def separa(text):
    linies = text.splitlines()
    separat = []
    info = ""
    llarg = 0
    for linea in linies:
        if len(linea) >= MAXTEXT:
            aux = separa_espais(info + linea)
            separat = separat + aux[: -1]
            info = (aux[-1] + "\n").lstrip("\n")
            llarg = len(info)
        elif llarg + len(linea) >= MAXTEXT:
            separat.append(info.rstrip("\n"))
            llarg = len(linea)
            info = (linea + "\n").lstrip("\n")
        else:
            llarg = llarg + len(linea)
            info = (info + linea + "\n").lstrip("\n")

    separat.append(info.rstrip(" \n"))

    return separat


async def envia(client, chat_id, text):
    linies = []
    if len(text) >= MAXTEXT:
        linies = separa(text)
        m = ()
        for linea in linies:
            m = await client.send_message(chat_id, linea, parse_mode="markdown")
        return(m)
    else:
        return await client.send_message(chat_id, text, parse_mode="markdown")


def normal(s):
    replacements = (
        ("Ã¡", "a"),
        ("Ã©", "e"),
        ("Ã­", "i"),
        ("Ã³", "o"),
        ("Ãº", "u"),
        ("Ã ", "a"),
        ("Ã¨", "e"),
        ("Ã¯", "i"),
        ("Ã²", "o"),
        ("Ã¼", "u"),
        ("Ã®", "i"),
    )
    for a, b in replacements:
        s = s.replace(a, b).replace(a.upper(), b.upper())
    return s


def cerca(paraula, language="en"):
    _ = translations[language].gettext
    cerca = normal(paraula).lower()
    resultats = []
    for r in all_regions:
        if normal(_(r)).lower().find(cerca) > -1:
            resultats.append(r)
    return resultats


def region_sort_key(language=None):
    def sort_function(elem):
        if elem.startswith("total-"):
            return "ZZZ"
        if language:
            _ = translations[language].gettext
            return normal(_(elem))
        return normal(elem)
    return sort_function


def get_label(region='total-world', language='en'):
    _ = translations[language].gettext
    label = '\n' + _('__Generated by [COVID19gram](t.me/COVID19gram_bot)__') + '\n'
    scope = cplt.get_region_scope(region)
    if scope == 'world':
        label += _('__Data source from__') + ' __[CSSEGISandData/COVID-19](https://github.com/CSSEGISandData/COVID-19)__'
    elif scope == 'spain':
        label += _('__Data source from__') + ' __[Datadista](https://github.com/datadista/datasets/)__'
    elif scope == 'italy':
        label += _('__Data source from__') + ' __[Ministero della Salute (Italia)](https://github.com/pcm-dpc/COVID-19)__'
    elif scope == 'france':
        label += _('__Data source from__') + ' __[OpenCOVID19-fr](https://github.com/opencovid19-fr)__'
    return label


def get_caption(region, plot_type="daily_cases", language="en", scope=False):
    # scp = cplt.get_region_scope(region)
    # if plot_type == 'recovered' and region == f"total-{scope}" and scp in cplt.AGES:
    #     return cplt.get_plot_caption(plot_type, region, language)
    if scope:
        scope_region = region.replace('total-', '')
        plot_caption = cplt.get_scope_plot_caption(plot_type=plot_type, scope=scope_region, language=language)
        return plot_caption

    _ = translations[language].gettext
    flaged_region = region
    if region in countries:
        flaged_region = countries[region]['flag'] + _(region)
    else:
        flaged_region = _(region)
    title = ""
    footer = ""
    if plot_type == "daily_cases":
        title = _('Cases increase at {region}').format(region=flaged_region)
    elif plot_type == "daily_hospitalized":
        title = _('Hospitalization evolution at {region}').format(region=flaged_region)
    elif plot_type == "active_recovered_deceased":
        title = _('Active cases, recovered and deceased at {region}').format(region=flaged_region)
        if region in cplt.get_regions('italy') or region == 'total-france':
            title = _('Active cases, hospitalized, recovered and deceased at {region}').format(region=_(region))
        elif region in cplt.get_regions('france'):
            title = _('Currently hospitalized, recovered and deceased at {region}').format(region=_(region))
    elif plot_type == "active":
        title = _('Active cases at {region}').format(region=flaged_region)
        if region in cplt.get_regions('france') and region != "total-france":
            title = _('Active hospitalizations at {region}').format(region=flaged_region)
    elif plot_type == "cases":
        title = _('Cumulative cases at {region}').format(region=flaged_region)
        if region in cplt.get_regions('france') and region != "total-france":
            title = _('Active hospitalizations at {region}').format(region=flaged_region)
    elif plot_type == "recovered":
        title = _('Recovered cases at {region}').format(region=flaged_region)
        scp = cplt.get_region_scope(region)
        if region == f"total-{scp}" and scp in cplt.AGES:
            title = _("Cases (Deaths) by age:")
    elif plot_type == "daily_deceased":
        title = _('Deaths evolution at {region}').format(region=flaged_region)
    elif plot_type == "hospitalized":
        title = _('Active hospitalizations at {region}').format(region=_(region))
    if plot_type == "summary":
        title = _('COVID-19 status at {region}').format(region=flaged_region)
        plot_caption = cplt.get_summary(region=region, language=language)
        # footer = "\n__" + _("More information and plots at") + " @COVID19gram_bot__\n"
        footer = ""
    else:
        plot_caption = cplt.get_plot_caption(plot_type=plot_type, region=region, language=language)
    return f'**{title}**\n\n{plot_caption}{footer}'


def botons(plot_type="daily_cases", regio="total-world", scope="spain", language="en", method=None, acum_regions_key=None):
    _ = translations[language].gettext
    ibt = []
    l_botns = []
    botonets = []
    result_all = []
    acum_regions = []
    regions = cplt.get_regions(scope)
    regions.sort(key=region_sort_key(language))

    if acum_regions_key:
        cache_acum_regions = cache.get(acum_regions_key)
        if cache_acum_regions:
            acum_regions = cache_acum_regions.decode("utf-8").split('_')

    for chart in list(string.ascii_lowercase):
        result = [i for i in regions if normal(_(i)[0]).lower() == chart and i != "total-world" and i not in acum_regions]
        result_all.extend(result)
        if len(result_all) > 7 or chart == "z":
            for item in result_all:
                flag = ""
                if item in countries:
                    flag = countries[item]['flag']
                cb = ""
                if method:
                    cb = method + "_"
                cb = cb + item + "_" + plot_type.replace('_', '-')
                ibt.append(InlineKeyboardButton(flag + _(item), callback_data=cb))
            botonets = [ibt[i * 3:(i + 1) * 3] for i in range((len(ibt) // 3) + 1)]
            cb = "back_" + scope
            if method:
                cb = cb + '_' + method
                if acum_regions_key:
                    cb = cb + '_' + acum_regions_key
            botonets.extend([[InlineKeyboardButton(_("â¬…ï¸Back"), callback_data=cb)]])
            btns = InlineKeyboardMarkup(botonets)
            l_botns.append(btns)
            ibt = []
            botonets = []
            result_all = []
    return l_botns


def b_alphabet(scope, plot_type="daily_cases", regio="total-world", method=None, acum_regions_key=None, language="en"):
    _ = translations[language].gettext
    ibt = []
    botonets = []
    ordre = 0
    text = ""
    len_all = 0
    s_char = ""
    regions = cplt.get_regions(scope)
    regions.sort(key=region_sort_key(language))
    ibt.append(InlineKeyboardButton("ðŸŒ" + _("Global"), callback_data="total-world_" + plot_type.replace('_', '-')))
    for chart in list(string.ascii_lowercase):
        result = [i for i in regions if normal(_(i)[0]).lower() == chart and i != "total-world"]
        len_all += len(result)
        if len_all > 7 or chart == "z":
            if s_char == "":
                text = chart.upper()
            else:
                text = s_char + "-" + chart.upper()
            s_char = ""
            len_all = 0
            cb = "alph_" + str(ordre) + "_" + scope
            if method:
                cb = cb + "_" + method
                if acum_regions_key:
                    cb = cb + '_' + acum_regions_key
            ibt.append(InlineKeyboardButton(text, callback_data=cb))
            ordre += 1
        elif len(result) > 0:
            if s_char == "":
                s_char = chart.upper()
    botonets = [ibt[i * 3:(i + 1) * 3] for i in range((len(ibt) // 3) + 1)]
    if method == 'compare':
        botonets.append([
            InlineKeyboardButton("âœ… " + _("Done"), callback_data="compare_finish_cases-normalized")
        ])
    btns = InlineKeyboardMarkup(botonets)
    return btns


def b_single(user_id, plot_type="daily_cases", region="total-world", language="en"):
    _ = translations[language].gettext
    fav_emoji = "ðŸ–¤"
    fav_label = "fav"
    p_type = plot_type.replace('_', '-')
    recovered_emoji = "âœ…"
    if dbhd.is_subscribed(user_id, region):
        fav_emoji = "ðŸ’›"
        fav_label = "unfav"
    scope = cplt.get_region_scope(region)
    if region == f"total-{scope}" and scope in cplt.AGES:
        recovered_emoji = "ðŸš»"
    buttons = [[
        InlineKeyboardButton("ðŸ¦ ", callback_data="s_" + region + "_daily-cases"),
        InlineKeyboardButton("ðŸ“Š", callback_data="s_" + region + "_active-recovered-deceased"),
        InlineKeyboardButton("ðŸ“ˆ", callback_data="s_" + region + "_cases"),
        InlineKeyboardButton(recovered_emoji, callback_data="s_" + region + "_recovered"),
        InlineKeyboardButton("âŒ", callback_data="s_" + region + "_daily-deceased"),
        InlineKeyboardButton(fav_emoji, callback_data=fav_label + "_" + region + "_" + p_type),
    ]]
    if region.startswith("total-"):
        buttons.extend([[
            InlineKeyboardButton("ðŸ¦ ðŸ—º", callback_data="scope_" + region + "_cases"),
            InlineKeyboardButton("ðŸ¦ ðŸ†•", callback_data="scope_" + region + "_increase-cases-normalized-heatmap"),
            InlineKeyboardButton("ðŸ¦ ðŸ–‡", callback_data="scope_" + region + "_acum14-cases-normalized-heatmap")],
            [
            InlineKeyboardButton("âŒ", callback_data="scope_" + region + "_deceased-normalized"),
            InlineKeyboardButton("âŒðŸ–‡", callback_data="scope_" + region + "_acum14-deceased-normalized-heatmap"),
        ]])

    buttons.append([
        InlineKeyboardButton("â¬‡ï¸ " + _("Send all plots"), callback_data="sendall_" + region),
        InlineKeyboardButton("ðŸ“Š " + _("Add region to compare"), callback_data="compare_" + region),
    ])
    btns = InlineKeyboardMarkup(buttons)
    return btns


def b_compare(language="en"):
    _ = translations[language].gettext
    buttons = [[
        InlineKeyboardButton("ðŸ¦ ", callback_data="compare_finish_cases-normalized"),
        InlineKeyboardButton("ðŸ“Š", callback_data="compare_finish_cases"),
        InlineKeyboardButton("ðŸ—‚", callback_data="compare_finish_cases-logarithmic"),
        # InlineKeyboardButton("âœ…", callback_data="s_" + region + "_recovered"),
        InlineKeyboardButton("âŒ", callback_data="compare_finish_deceased-normalized"),
    ]]

    # buttons.append([
    #     InlineKeyboardButton("â¬‡ï¸ " + _("Send all plots"), callback_data="sendall_" + region),
    # ])
    btns = InlineKeyboardMarkup(buttons)
    return btns


def b_find(search, plot_type="daily_cases", language="en"):
    _ = translations[language].gettext
    taula = cerca(search, language)
    ibt = []
    l_botns = []
    botonets = []
    pageSize = 18
    max = len(taula) // pageSize

    if len(taula) % pageSize != 0:
        max = len(taula) // pageSize + 1

    for pag in range(max):
        for item in taula[pag * pageSize:(pag + 1) * pageSize]:
            flag = ""
            if item in countries:
                flag = countries[item]['flag']
            ibt.append(InlineKeyboardButton(flag + _(item), callback_data=item + "_" + plot_type.replace('_', '-')))
        botonets = [ibt[i * 3:(i + 1) * 3] for i in range((len(ibt) // 3) + 1)]
        if pag == 0 and pag != max - 1:
            botonets.extend([[InlineKeyboardButton(">>", callback_data="f_" + str(pag + 1) + "_" + search)]])
        elif pag == max - 1 and pag != 0:
            botonets.extend([[InlineKeyboardButton("<<", callback_data="f_" + str(pag - 1) + "_" + search)]])
        elif pag > 0 and pag < max - 1:
            botonets.extend([[
                InlineKeyboardButton("<<", callback_data="f_" + str(pag - 1) + "_" + search),
                InlineKeyboardButton(">>", callback_data="f_" + str(pag + 1) + "_" + search)]])
        btns = InlineKeyboardMarkup(botonets)
        l_botns.append(btns)
        ibt = []
        botonets = []
    return l_botns


async def b_fav(user, plot_type="daily_cases", language="en"):
    _ = translations[language].gettext
    regions = await dbhd.get_subscriptions(user)
    ibt = []
    l_botns = []
    botonets = []
    pageSize = 18
    max = len(regions) // pageSize

    if len(regions) % pageSize != 0:
        max = len(regions) // pageSize + 1

    for pag in range(max):
        for item in regions[pag * pageSize:(pag + 1) * pageSize]:
            flag = ""
            if item in countries:
                flag = countries[item]['flag']
            ibt.append(InlineKeyboardButton(flag + _(item), callback_data=item + "_" + plot_type.replace('_', '-')))
        botonets = [ibt[i * 3:(i + 1) * 3] for i in range((len(ibt) // 3) + 1)]
        if pag == 0 and pag != max - 1:
            botonets.extend([[InlineKeyboardButton(">>", callback_data="subs_" + str(pag + 1))]])
        elif pag == max - 1 and pag != 0:
            botonets.extend([[InlineKeyboardButton("<<", callback_data="subs_" + str(pag - 1))]])
        elif pag > 0 and pag < max - 1:
            botonets.extend([[
                InlineKeyboardButton("<<", callback_data="subs_" + str(pag - 1)),
                InlineKeyboardButton(">>", callback_data="subs_" + str(pag + 1))]])
        btns = InlineKeyboardMarkup(botonets)
        l_botns.append(btns)
        ibt = []
        botonets = []
    return l_botns


def b_regions(scope, plot_type="daily_cases", method=None, acum_regions=[], language="en"):
    _ = translations[language].gettext
    ibt = []
    botonets = []
    regions = cplt.get_regions(scope)
    regions.sort(key=region_sort_key(language))
    for item in regions:
        if item in acum_regions:
            continue
        cb = ""
        if method:
            cb = method + "_"
        cb = cb + item + "_" + plot_type.replace('_', '-')
        ibt.append(InlineKeyboardButton(_(item), callback_data=cb))
    botonets = [ibt[i * 3:(i + 1) * 3] for i in range((len(ibt) // 3) + 1)]
    if method == 'compare':
        botonets.append([
            InlineKeyboardButton("âœ… " + _("Done"), callback_data="compare_finish_cases-normalized")
        ])
    btns = InlineKeyboardMarkup(botonets)
    return btns


def b_conf(user_id, language="en"):
    _ = translations[language].gettext
    lang_dicc = {'en': 'âš«ï¸', 'es': 'âš«ï¸', 'ca': 'âš«ï¸', 'it': 'âš«ï¸'}
    lang_dicc[language] = 'ðŸ”µ'
    buttons = {'gl': 'âš«ï¸', 'es': 'âš«ï¸', 'it': 'âš«ï¸', 'fr': 'âš«ï¸'}
    btn_status = {'gl': 'on', 'es': 'on', 'it': 'on', 'fr': 'on'}
    for button in dbhd.get_buttons(user_id):
        buttons[button] = 'ðŸ”µ'
        btn_status[button] = 'off'
    cb_estat = 'on'
    notificacions = dbhd.get_notifications(user_id)
    emj_notf = ['ðŸ”µ' if x == 1 else 'âš«ï¸' for x in notificacions]
    cb_estat = ['off' if x == 1 else 'on' for x in notificacions]
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton(_("Notify me of updates to"), callback_data="blank")
        ],
        [
            InlineKeyboardButton(emj_notf[0] + " " + _("ðŸŒGlobal"), callback_data="notf_world_" + cb_estat[0]),
            InlineKeyboardButton(emj_notf[1] + " " + _("ðŸ‡ªðŸ‡¸Spain"), callback_data="notf_spain_" + cb_estat[1])
        ],
        [
            InlineKeyboardButton(emj_notf[2] + " " + _("ðŸ‡®ðŸ‡¹Italy"), callback_data="notf_italy_" + cb_estat[2]),
            InlineKeyboardButton(emj_notf[3] + " " + _("ðŸ‡«ðŸ‡·France"), callback_data="notf_france_" + cb_estat[3]),
        ],
        [
            InlineKeyboardButton(_("Choose Language"), callback_data="blank")
        ],
        [
            InlineKeyboardButton(lang_dicc['en'] + " " + "English", callback_data="lang_en"),
            InlineKeyboardButton(lang_dicc['ca'] + " " + "CatalÃ ", callback_data="lang_ca")
        ],
        [
            InlineKeyboardButton(lang_dicc['es'] + " " + "EspaÃ±ol", callback_data="lang_es"),
            InlineKeyboardButton(lang_dicc['it'] + " " + "Italiano", callback_data="lang_it"),
        ],
        [
            InlineKeyboardButton(_("Show buttons for:"), callback_data="blank")
        ],
        [
            InlineKeyboardButton(buttons['gl'] + " " + _("ðŸŒGlobal"), callback_data=f"button_{btn_status['gl']}_gl"),
            InlineKeyboardButton(buttons['es'] + " " + _("ðŸ‡ªðŸ‡¸Spain"), callback_data=f"button_{btn_status['es']}_es"),
        ],
        [
            InlineKeyboardButton(buttons['it'] + " " + _("ðŸ‡®ðŸ‡¹Italy"), callback_data=f"button_{btn_status['it']}_it"),
            InlineKeyboardButton(buttons['fr'] + " " + _("ðŸ‡«ðŸ‡·France"), callback_data=f"button_{btn_status['fr']}_fr"),
        ]
    ])


def b_start(user_id, language="en"):
    _ = translations[language].gettext
    names = {
        'gl': _("ðŸŒGlobal"),
        'es': _("ðŸ‡ªðŸ‡¸Spain"),
        'it': _("ðŸ‡®ðŸ‡¹Italy"),
        'fr': _("ðŸ‡«ðŸ‡·France")
    }
    buttons = dbhd.get_buttons(user_id)
    scopes = []
    for button in buttons:
        scopes.append(names[button])

    rep_markup = ReplyKeyboardMarkup([
        scopes,
        [_("âš™ï¸Conf."), _("â“About"), _("ðŸ’›FAVs")]],
        resize_keyboard=True)
    return rep_markup


async def set_language(user_id, language):
    await dbhd.set_language(user_id, language)


async def get_language(user):
    language = await dbhd.get_language(user.id)
    if language != 'None':
        return language
    elif user.language_code and user.language_code in cplt.LANGUAGES:
        await set_language(user.id, user.language_code)
        return user.language_code
    else:
        await set_language(user.id, 'en')
        return 'en'


async def send_photo(client, chat, photo, caption="", reply_markup=[]):
    if await dbhd.has_image_hash(photo):
        flname = await dbhd.get_image_hash(photo)
        message = await client.send_photo(chat, photo=flname, caption=caption, reply_markup=reply_markup)
    else:
        flname = photo
        message = await client.send_photo(chat, photo=flname, caption=caption, reply_markup=reply_markup)
        hash = message.photo.file_id
        await dbhd.set_image_hash(hash, flname)
    return message


async def edit_message_media(client, chat, mid, photo, caption, reply_markup):
    message = None
    if await dbhd.has_image_hash(photo):
        message = flname = await dbhd.get_image_hash(photo)
        await client.edit_message_media(chat, mid, InputMediaPhoto(media=flname, caption=caption), reply_markup=reply_markup)
    else:
        flname = photo
        message = await client.edit_message_media(chat, mid, InputMediaPhoto(media=flname, caption=caption), reply_markup=reply_markup)
        hash = message.photo.file_id
        await dbhd.set_image_hash(hash, flname)
    return message


async def show_region(client, chat, plot_type="daily_cases", region="total-world", language='en', is_scope=False, simple=False):
    _ = translations[language].gettext
    btns = []
    if not simple:
        btns = b_single(chat, plot_type=plot_type, region=region, language=language)
    if is_scope:
        scope = region.replace('total-', '')
        flname = cplt.generate_scope_plot(plot_type=plot_type, scope=scope, language=language)
        caption = get_caption(region, plot_type=plot_type, language=language, scope=True)
    else:
        region_scope = cplt.get_region_scope(region)
        if region_scope == 'france' and plot_type == 'daily_cases' and region != 'total-france':
            plot_type = 'daily_hospitalized'
        flname = cplt.generate_plot(plot_type=plot_type, region=region, language=language)
        caption = get_caption(region, plot_type=plot_type, language=language)
    try:
        await send_photo(client, chat, photo=flname, caption=caption, reply_markup=btns)
    except BadRequest as e:
        if str(e).find("IMAGE_PROCESS_FAILED") > -1:
            os.remove(flname)
            if is_scope:
                flname = cplt.generate_scope_plot(plot_type=plot_type, scope=scope, language=language)
            else:
                flname = cplt.generate_plot(plot_type=plot_type, region=region, language=language)
            await send_photo(client, chat, photo=flname, caption=caption, reply_markup=btns)
        elif str(e).find("MESSAGE_NOT_MODIFIED") > -1:
            logging.info("Error: " + str(e))
    except Exception as err:
        logging.info("Unexpected error:" + str(type(err)) + " - " + str(err))
        raise


async def send_regions(client, chat, region="Total", language='en', is_scope=False):
    _ = translations[language].gettext
    media = []
    flnames = []
    if is_scope:
        scope = region.replace('total-', '')
        for plot_type in cplt.BUTTON_PLOT_TYPES:
            flname = cplt.generate_plot(plot_type=plot_type, region=region, language=language)
            flnames.append(flname)
            if await dbhd.has_image_hash(flname):
                flname = await dbhd.get_image_hash(flname)
            media.append(InputMediaPhoto(
                flname,
                caption=get_caption(region, plot_type=plot_type, language=language)
            ))
        for plot_type in cplt.BUTTON_SCOPE_PLOT_TYPES:
            flname = cplt.generate_scope_plot(plot_type=plot_type, scope=scope, language=language)
            flnames.append(flname)
            if await dbhd.has_image_hash(flname):
                flname = await dbhd.get_image_hash(flname)
            media.append(InputMediaPhoto(
                flname,
                caption=get_caption(region, plot_type=plot_type, language=language, scope=True)
            ))
    else:
        region_scope = cplt.get_region_scope(region)
        for plot_type in cplt.BUTTON_PLOT_TYPES:
            if region_scope == 'france' and plot_type == 'daily_cases' and region != 'total-france':
                plot_type = 'daily_hospitalized'
            flname = cplt.generate_plot(plot_type=plot_type, region=region, language=language)
            flnames.append(flname)
            if await dbhd.has_image_hash(flname):
                flname = await dbhd.get_image_hash(flname)
            media.append(InputMediaPhoto(
                flname,
                caption=get_caption(region, plot_type=plot_type, language=language)
            ))

    try:
        messages = await client.send_media_group(chat, media=media)
        media_index = 0
        for msg in messages:
            if not await dbhd.has_image_filename(msg.photo.file_id):
                hash = msg.photo.file_id
                flname = flnames[media_index]
                await dbhd.set_image_hash(hash, flname)
            media_index += 1
    except BadRequest as e:
        if str(e).find("IMAGE_PROCESS_FAILED") > -1:
            for photo in media:
                os.remove(photo.media)
        elif str(e).find("MESSAGE_NOT_MODIFIED") > -1:
            logging.info("Error: " + str(e))
    except Exception as err:
        logging.info("Unexpected error:" + str(type(err)) + " - " + str(err))
        raise


async def edit_region(client, chat, mid, plot_type="daily_cases", region="Total", language="en", is_scope=False, compare=False):
    _ = translations[language].gettext
    btns = b_single(chat, plot_type=plot_type, region=region, language=language)

    if is_scope:
        scope = region.replace('total-', '')
        flname = cplt.generate_scope_plot(plot_type=plot_type, scope=scope, language=language)
        caption = get_caption(region, plot_type=plot_type, language=language, scope=True)
    elif compare:
        regions = cache.get(f"{CACHE_PREFIX}_compare_{chat}_{mid}")
        region_scope = ''
        if not regions:
            regions = []
        else:
            regions = regions.decode("utf-8").split('_')
            region_scope = cplt.get_region_scope(regions[0])
        if region_scope == 'france' and 'cases' in plot_type:
            plot_type = plot_type.replace('cases', 'hospitalized')
        flname = cplt.generate_multiregion_plot(plot_type=plot_type, regions=regions, language=language)
        caption = _("Comparison of cases in ") + ', '.join([_(region) for region in regions])
        btns = b_compare(language)
    else:
        region_scope = cplt.get_region_scope(region)
        if region_scope == 'france' and plot_type == 'daily_cases' and region != 'total-france':
            plot_type = 'daily_hospitalized'
        flname = cplt.generate_plot(plot_type=plot_type, region=region, language=language)
        caption = get_caption(region, plot_type=plot_type, language=language)
    try:
        await edit_message_media(client, chat, mid, flname, caption=caption, reply_markup=btns)
    except BadRequest as e:
        if str(e).find("IMAGE_PROCESS_FAILED") > -1:
            os.remove(flname)
            if is_scope:
                flname = cplt.generate_scope_plot(plot_type=plot_type, scope=scope, language=language)
            else:
                flname = cplt.generate_plot(plot_type=plot_type, region=region, language=language)
            await edit_message_media(client, chat, mid, flname, caption=caption, reply_markup=btns)
        elif str(e).find("MESSAGE_NOT_MODIFIED") > -1:
            logging.info("Error: " + str(e))
    except Exception as err:
        logging.info("Unexpected error:" + str(type(err)) + " - " + str(err))
        raise


async def send_notifications():
    updated = update_data()
    _ = translations['en'].gettext
    text = {
        'world': _('ðŸŒGlobal data updated'),
        'spain': _('ðŸ‡ªðŸ‡¸Spain data updated'),
        'italy': _('ðŸ‡®ðŸ‡¹Italy data updated'),
        'france': _('ðŸ‡«ðŸ‡·France data updated'),
    }
    for scope in cplt.SCOPES:
        if scope != 'france' and updated[scope]:
            for user_id in await dbhd.get_users_scope(scope):
                # await asyncio.sleep(1)
                language = await get_language(await app.get_users(user_id))
                _ = translations[language].gettext
                try:
                    await app.send_message(user_id, _(text[scope]))
                except Exception as e:
                    await exception_handle(user_id, e)


async def DoBot(comm, param, client, message, language="en", **kwargs):
    _ = translations[language].gettext
    user = message.from_user.id
    chat = message.chat.id
    md_param = ""
    if 'md_param' in kwargs and kwargs['md_param'] != "":
        md_param = kwargs['md_param']
    if comm == "start":
        language = await get_language(message.from_user)
        _ = translations[language].gettext
        rep_markup = b_start(user, language)
        await client.send_message(chat, _("âš™ï¸Main Menu"), reply_markup=rep_markup)
    elif comm == "italy":
        btns = b_regions('italy', language=language)
        caption = _("Choose a Region")
        flname = cplt.generate_scope_plot(plot_type='cases', scope="italy", language=language)
        await send_photo(client, chat, photo=flname, caption=caption, reply_markup=btns)
    elif comm == "france":
        btns = b_regions('france', language=language)
        caption = _("Choose a Region")
        flname = cplt.generate_scope_plot(plot_type='hospitalized', scope="france", language=language)
        await send_photo(client, chat, photo=flname, caption=caption, reply_markup=btns)
    elif comm == "spain":
        btns = b_regions('spain', language=language)
        caption = _("Choose a Region")
        flname = cplt.generate_scope_plot(plot_type='cases', scope="spain", language=language)
        await send_photo(client, chat, photo=flname, caption=caption, reply_markup=btns)
        # await client.send_message(chat, caption, reply_markup=btns)
    elif comm == "world":
        btns = b_alphabet(scope="world", language=language)
        caption = _("Choose a Region")
        flname = cplt.generate_scope_plot(plot_type='cases', scope="world", language=language)
        await send_photo(client, chat, photo=flname, caption=caption, reply_markup=btns)
        # await client.send_message(chat, caption, reply_markup=btns)
    elif comm == "clean" and user in admins:
        await client.send_message(chat, "Cleanig images cache.")
        filelist = [f for f in os.listdir("images") if f.endswith(".png")]
        await dbhd.clean_hashes()
        for f in filelist:
            os.remove(os.path.join("images", f))
        await client.send_message(chat, "Cleaned.")
    elif comm == "update" and user in admins:
        await client.send_message(chat, "Updating data.")
        await send_notifications()
        await client.send_message(chat, "Data Updated.")
    elif comm == "status" and user in admins:
        text = status_data()
        text += "\n" + await dbhd.status_users()
        text += "\n" + await dbhd.status_notifications()
        text += "\n" + await dbhd.status_files()
        await envia(client, chat, text)
    elif comm == 'bc' and user in admins:
        ilkb = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("Send Cat", callback_data="bc_ca"),
                InlineKeyboardButton("Send ðŸ‡ªðŸ‡¸", callback_data="bc_es"),
                InlineKeyboardButton("Send ðŸ‡¬ðŸ‡§", callback_data="bc_en"),
            ],
            [
                InlineKeyboardButton("Send ðŸ‡®ðŸ‡¹", callback_data="bc_it"),
                InlineKeyboardButton("Send ðŸŒ", callback_data="bc_all"),
                InlineKeyboardButton("Cancel", callback_data="bc_none"),
            ]
        ])
        await client.send_message(chat, md_param, parse_mode=None, disable_web_page_preview=True)
        await client.send_message(chat, md_param, reply_markup=ilkb, disable_web_page_preview=True)
    elif comm == "find":
        if len(param) > 0:
            resultats = cerca(param, language=language)
            if len(resultats) == 0:
                rep_markup = b_start(user, language)
                await client.send_message(chat, _('No results for `{param}`').format(param=param), reply_markup=rep_markup)
            elif len(resultats) == 1:
                await show_region(client, chat, region=resultats[0])
            else:
                btns = b_find(param, language=language)[0]
                caption = f'Search Results for `{param}`'
                await client.send_message(chat, caption, reply_markup=btns)
    elif comm == "favs":
        lbtns = await b_fav(user, language=language)
        if len(lbtns) == 0:
            await client.send_message(chat, _("You have no subscription").format(param=param))
        else:
            btns = lbtns[0]
            caption = _("**Your subscriptions:**")
            await client.send_message(chat, caption, reply_markup=btns)

    elif comm == "about":
        about = _("**Chart Buttons**") + "\n"
        about += "ðŸ¦  - __" + _("Case increase") + ".__\n"
        about += "ðŸ“Š - __" + _("Active cases, recovered and deceased") + ".__\n"
        about += "ðŸ“ˆ - __" + _("Cumulative cases") + ".__\n"
        about += "âœ… - __" + _("Recovered cases") + ".__\n"
        about += "âŒ - __" + _("Daily deaths evolution") + ".__\n"
        about += "â¬‡ï¸ - __" + _("Send all plots as an album") + ".__\n"
        about += "ðŸ“Š  - __" + _("Add region to compare") + ".__\n"
        about += '\n'
        about += "**" + _("Additional buttons. Top 20s for ðŸŒGlobal and detailed Spain scopes") + ":**\n"
        about += "ðŸ¦ ðŸ—º - __" + _("Active cases per region") + ".__\n"
        about += "ðŸ¦ % - __" + _("Cases rate per 100K inhabitants") + ".__\n"
        about += "ðŸ“ˆðŸ†• - __" + _("New cases rate per 100K inhabitants") + ".__\n"
        about += "âŒ% - __" + _("Deceased rate per 100K inhabitants") + ".__\n"
        about += "âŒðŸ†• - __" + _("New deceased rate per 100K inhabitants") + ".__\n"
        about += '\n'

        about += _("**Data Sources**") + "\n"
        about += "ðŸ—‚" + _('__Spain data source from__') + ' __[Datadista](https://github.com/datadista/datasets/)__\n'
        about += "ðŸ—‚" + _('__World data source from__') + ' __[JHU CSSE](https://github.com/CSSEGISandData/COVID-19)__, '
        about += _('__transformed to JSON by__') + ' __[github.com/pomber](https://github.com/pomber/covid19)__\n'
        about += "ðŸ—‚" + _('__Italy data source from__') + ' __[Ministero della Salute (Italia)](https://github.com/pcm-dpc/COVID-19)__\n'
        about += "ðŸ—‚" + _('__France data source from__') + ' __[OpenCOVID19-fr](https://opencovid19.fr)__\n'
        about += '\n'
        about += _("**Contact**") + '\n'
        about += _("You can contact us using") + " [@C19G_feedbackbot](t.me/C19G_feedbackbot)" + "\n"

        about += _("**Code availability**") + "\n"
        about += _('Source code available soon.') + '\n'
        about += '\nï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿ï¼¿'

        rep_markup = b_start(user, language)
        await client.send_message(chat, about, disable_web_page_preview=True, reply_markup=rep_markup)


@app.on_message(filters.text)
async def g_request(client, message):
    chat = message.chat.id
    user_id = message.from_user.id
    language = await get_language(message.from_user)
    _ = translations[language].gettext
    if message.text.startswith('/'):
        comm = message.text.split()[0].strip('/')
        param = ""
        if re.match('^/' + comm + ' .+', message.text):
            param = re.search('^/' + comm + ' (.+)', message.text).group(1)
        md_param = message.text.markdown.replace('/' + comm, '', 1)
        await DoBot(comm, param, client, message, language, md_param=md_param)
    elif message.text == _("ðŸŒGlobal"):
        await DoBot("world", "", client, message, language)
    elif message.text == _("ðŸ‡ªðŸ‡¸Spain"):
        await DoBot("spain", "", client, message, language)
    elif message.text == _("ðŸ‡®ðŸ‡¹Italy"):
        await DoBot("italy", "", client, message, language)
    elif message.text == _("ðŸ‡«ðŸ‡·France"):
        await DoBot("france", "", client, message, language)
    elif message.text == _("âš™ï¸Conf."):
        btns = b_conf(user_id, language)
        await client.send_message(chat, _("âš™ï¸ **Configuration:**"), reply_markup=btns)
    elif message.text == _("â“About"):
        await DoBot("about", "", client, message, language)
    elif message.text == _("ðŸ’›FAVs"):
        await DoBot("favs", "", client, message, language)
    else:
        param = message.text
        resultats = cerca(param, language)
        if len(resultats) == 0:
            await client.send_message(chat, _('No results for `{param}`').format(param=param))
        elif len(resultats) == 1:
            await show_region(client, chat, region=resultats[0], language=language)
        else:
            btns = b_find(param, language=language)[0]
            caption = _('Search results for `{param}`').format(param=param)
            await client.send_message(chat, caption, reply_markup=btns)


@app.on_callback_query()
async def answer(client, callback_query):
    user = callback_query.from_user
    user_id = callback_query.from_user.id
    chat = callback_query.message.chat.id
    mid = callback_query.message.message_id
    params = callback_query.data.split("_")
    comm = params[0]
    language = await get_language(user)
    _ = translations[language].gettext
    if comm == "pag":
        logging.info("****** entra a pag ****")
        pag = int(params[1])
        btns = botons(scope='spain')[pag]
        caption = _("Choose a Region")
        await client.edit_message_text(chat, mid, caption, reply_markup=btns)

    elif comm == "bc" and user.id in admins:
        lang = params[1]
        if lang in cplt.LANGUAGES or lang == "all":
            for user_id in await dbhd.get_users_lang(lang):
                # await asyncio.sleep(1)
                try:
                    language = await get_language(await client.get_users(user_id))
                    _ = translations[language].gettext
                    rep_markup = b_start(user_id, language)
                    await client.send_message(user_id, _("**Announcement:**") + "\n\n" + callback_query.message.text.markdown, disable_web_page_preview=True, reply_markup=rep_markup, disable_notification=True)
                except Exception as e:
                    await exception_handle(user_id, e)
            await client.send_message(user.id, f'The message has been send to `{lang}`.')
        else:
            await client.send_message(user.id, "Canceled.")
        await callback_query.message.delete()

    elif comm == "back":
        scope = params[1]
        method = None
        if len(params) > 2:
            method = params[2]
        acum_regions_key = None
        if len(params) > 3:
            acum_regions_key = params[3]
        btns = b_alphabet(scope=scope, language=language, method=method, acum_regions_key=acum_regions_key)
        if not method:
            caption = _("Choose a Region")
            await client.edit_message_text(chat, mid, caption, reply_markup=btns)
        else:
            await client.edit_message_reply_markup(chat, mid, reply_markup=btns)

    elif comm == "s":
        region = params[1]
        plot_type = params[2].replace('-', '_')
        if region in all_regions:
            await edit_region(client, chat, mid, plot_type, region, language=language)

    elif comm == "sendall":
        region = params[1]
        await client.send_message(chat, _("Generating all plots, it may take some time."))
        if region in all_regions:
            if region.startswith("total-"):
                await send_regions(client, chat, region=region, language=language, is_scope=True)
            else:
                await send_regions(client, chat, region=region, language=language)

    elif comm == "compare":
        region = params[1]

        if region == 'finish':
            plot_type = params[2].replace('-', '_')
            await edit_region(client, chat, mid, plot_type=plot_type, language=language, compare=True)
            return
        cache_key = f"{CACHE_PREFIX}_{comm}_{chat}_{mid}"
        regions = cache.get(cache_key)
        if not regions:
            regions = []
        else:
            regions = regions.decode("utf-8").split('_')
        regions.append(region)
        cache.setex(
            cache_key,
            timedelta(minutes=60),
            value='_'.join(regions))
        if len(regions) > 8:
            plot_type = 'cases_normalized'
            await edit_region(client, chat, mid, plot_type=plot_type, language=language, compare=True)
            return
        scope = cplt.get_region_scope(region)
        if scope == 'world':
            btns = b_alphabet(scope="world", method='compare', acum_regions_key=cache_key, language=language)
        else:
            btns = b_regions(scope=scope, method='compare', acum_regions=regions, language=language)
        text = _("Choose a Region to compare with ") + ', '.join([_(region) for region in regions])
        await client.edit_message_text(chat, mid, text, reply_markup=btns)

    elif comm == "scope":
        region = params[1]
        plot_type = params[2].replace('-', '_')
        if region.startswith("total-"):
            await edit_region(client, chat, mid, plot_type, region, language=language, is_scope=True)

    if comm == "lang":
        language = params[1]
        _ = translations[language].gettext
        await set_language(user.id, language)
        rep_markup = b_start(user.id, language)
        await client.send_message(chat, _("Your language is now English"), reply_markup=rep_markup, disable_notification=True)
        rep_markup = b_conf(user.id, language)
        await client.edit_message_text(chat, mid, _("âš™ï¸ **Configuration:**"), reply_markup=rep_markup)

    if comm == "button":
        button = params[2]
        status = params[1]
        if await dbhd.set_button(user.id, button, status):
            rep_markup = b_start(user.id, language)
            await client.send_message(chat, _("Buttons updated"), reply_markup=rep_markup, disable_notification=True)
            rep_markup = b_conf(user.id, language)
            await client.edit_message_text(chat, mid, _("âš™ï¸ **Configuration:**"), reply_markup=rep_markup)
        else:
            await client.send_message(chat, _("You must select at least one button"), disable_notification=True)

    if comm == "notf":
        scope = params[1]
        status = params[2]
        rep_markup = b_start(user.id, language)
        await dbhd.set_notification(user.id, scope, status)
        # await client.send_message(chat, text, reply_markup=rep_markup, disable_notification=True)
        rep_markup = b_conf(user.id, language)
        await client.edit_message_text(chat, mid, _("âš™ï¸ **Configuration:**"), reply_markup=rep_markup)

    elif comm == "alph":
        pag = int(params[1])
        scope = params[2]
        method = None
        if len(params) > 3:
            method = params[3]
        btns = []
        if scope == 'world':
            btns = botons(scope=scope, language=language, method=method)[pag]
        else:
            btns = botons(scope=scope, language=language, method=method)[pag]
        if not method:
            caption = _("Choose a Region")
            await client.edit_message_text(chat, mid, caption, reply_markup=btns)
        else:
            await client.edit_message_reply_markup(chat, mid, reply_markup=btns)

    elif comm == "f":
        pag = int(params[1])
        param = params[2]
        btns = b_find(param, language=language)[pag]
        caption = _('Search results for `{param}`').format(param=param)
        await client.edit_message_text(chat, mid, caption, reply_markup=btns)

    elif comm == "subs":
        pag = int(params[1])
        user_id = user.id
        lbtns = await b_fav(user_id, language=language)
        btns = lbtns[pag]
        caption = _("**Your subscriptions:**")
        await client.edit_message_text(chat, mid, caption, reply_markup=btns)

    elif comm == "fav":
        user_id = user.id
        region = params[1]
        plot_type = params[2].replace('-', '_')
        is_scope = False
        await dbhd.add_subcription(user_id, region)
        if plot_type in cplt.SCOPE_PLOT_TYPES:
            is_scope = True
        await edit_region(client, chat, mid, plot_type, region, language=language, is_scope=is_scope)

    elif comm == "unfav":
        user_id = user.id
        region = params[1]
        plot_type = params[2].replace('-', '_')
        is_scope = False
        await dbhd.remove_subscription(user_id, region)
        if plot_type in cplt.SCOPE_PLOT_TYPES:
            is_scope = True
        await edit_region(client, chat, mid, plot_type, region, language=language, is_scope=is_scope)

    elif comm in all_regions:
        region = comm
        plot_type = params[1].replace('-', '_')
        await show_region(client, chat, plot_type, region, language=language)

    elif comm == "blank":
        logging.info('blank')


@app.on_inline_query()
async def answer_inline(client, inline_query):
    if len(inline_query.query) > 6:
        await inline_query.answer(
            results=[],
            is_personal=True,
            cache_time=20
        )
        return

    rslts = []
    resultats = []
    language = await get_language(inline_query.from_user)
    _ = translations[language].gettext

    if len(inline_query.query) < 1:
        regions = await dbhd.get_subscriptions(inline_query.from_user.id)
        if len(regions) > 0:
            resultats = regions[0:40]
        else:
            await inline_query.answer(
                results=[],
                is_personal=True,
                cache_time=20
            )
            return
    else:
        resultats = cerca(inline_query.query, language)
        resultats = resultats[0:40]

    for result in resultats:
        text = get_caption(result, plot_type="summary", language=language)
        flag = ""
        if result in countries:
            flag = countries[result]['flag']

        inlansw = InlineQueryResultArticle(
            id=uuid4(),
            title=flag + _(result),
            input_message_content=InputTextMessageContent(text),
        )
        rslts.append(inlansw)

    await inline_query.answer(
        results=rslts,
        is_personal=True,
        cache_time=20
    )


async def main():
    scheduler = AsyncIOScheduler()
    scheduler.add_job(send_notifications, "interval", hours=1)
    scheduler.start()
    await app.start()
    logging.info("Started")
    await idle()

if __name__ == "__main__":
    loop = asyncio.get_event_loop()
    loop.run_until_complete(main())
